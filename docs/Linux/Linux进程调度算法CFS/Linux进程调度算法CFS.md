# Linux进程调度算法-CFS

CFS - Completely Fair Scheduler, 完全公平调度器.
BFS和MuqSS比较适合桌面.

## CFS概述

**CFS能在真实硬件上模拟出一种“公平的、精确的任务多处理CP**

1. 公平，即对于n个正在运行的任务，当这些任务同时不断地运行时，CPU会尽可能分配给他们1/n的处理时间。CFS是一种基于加权公平排队思想的调度算法
2. 精确，指的是它采用红黑树作为调度的任务队列的数据结构

## CFS调度方式

1. CFS使用红黑树结构，来存储要调度的任务队列
2. 每个节点代表了一个要调度的任务，节点的key即为虚拟时间(vruntime)，虚拟时间由这个任务的运行时间计算而来
3. key越小，也就是vruntime越小的话，红黑树对应的节点就越靠左
4. CFS scheduler每次都挑选最左边的节点作为下一个要运行的任务，这个节点是“缓存的”——由一个特殊的指针指向；不需要进行$O(logn)$遍历来查找。也因此，CFS搜索的时间是$O(1)$
5. $$
运行时间tn=调度周期T * 当前进程权重w / 所有进程权重总和,
vruntime += 实际运行时间 * NICE_0_LOAD/ 当前进程权重
vruntime += 调度周期 * NICE_0_LOAD/ 所有进程权重总和, (分配给进程的运行时间=实际运行的时间时)
   $$

## 补充

### **新进程的vruntime的初值**
每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范

### **CFS阈值**
当系统中存在大量vruntime相似的线程之后，类似多米诺效应，线程调度将会被过于频繁的触发，这明显不合理.
于是就如何定义“vruntime触发调度”时，CFS引入了一个阈值，即如果前后两个线程vruntime保持在一个阈值之内，系统不会触发调度. 而这个阈值大小就是最小的调度时间片.

### **休眠进程的vruntime**
如果休眠进程的 vruntime 保持不变，而其他运行进程的 vruntime 一直在推进，那么等到休眠进程终于唤醒的时候，它的vruntime比别人小很多，会使它获得长时间抢占CPU的优势，其他进程就要饿死了。这显然是另一种形式的不公平。CFS是这样做的：在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿，但不能补偿太多