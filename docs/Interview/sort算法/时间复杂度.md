# 时间复杂度

| 排序法 | 平均时间 | 最差情形    | 稳定度 | 额外空间 | 备注                           |
| ------ | -------- | ----------- | ------ | -------- | ------------------------------ |
| 冒泡   | O(n2)    | O(n2)       | 稳定   | O(1)     | n小时较好                      |
| 选择   | O(n2)    | O(n2)       | 不稳定 | O(1)     | n小时较好                      |
| 插入   | O(n2)    | O(n2)       | 稳定   | O(1)     | 大部分已排序时较好             |
| 基数   | O(logRB) | O(logRB)    | 稳定   | O(n)     | B是真数(0-9)， R是基数(个十百) |
| Shell  | O(nlogn) | O(ns) 1<s<2 | 不稳定 | O(1)     | s是所选分组                    |
| 快速   | O(nlogn) | O(n2)       | 不稳定 | O(nlogn) | n大时较好，topK问题                   |
| 归并   | O(nlogn) | O(nlogn)    | 稳定   | O(n)     | n大时较好                      |
| 堆     | O(nlogn) | O(nlogn)    | 不稳定 | O(1)     | n大时较好                      |


## 基本思想

### 快排
选择一个数，大于他的放右边，小于他的放左边

### 归并
左右两边按顺序归并到一个数组

### 堆排序

1. 将待排序序列构造成一个大顶堆
2. 此时，整个序列的最大值就是堆顶的根节点。
3. 将其与末尾元素进行交换，此时末尾就为最大值。
4. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。